import datetime
import mido
import thespian.actors
import time


class SubscriptionManager(object):

    def __init__(self, send_func):
        self.subscribers = []
        self.send_func = send_func

    def new(self, subscriber):
        self.subscribers.append(subscriber)

    def send_message(self, message):
        for subscriber in self.subscribers:
            self.send_func(subscriber, message)


class MidiIn(thespian.actors.Actor):
    
    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_input('Launchpad MK2 MIDI 1')
        self.subscriptions = SubscriptionManager(send_func=self.send)
        self.wakeupAfter(datetime.timedelta())

    def next(self):
        midi_message = self.port.poll()
        if midi_message is not None:
            self.subscriptions.send_message(('midi-input-event', midi_message))
        self.wakeupAfter(datetime.timedelta(milliseconds=10))
        
    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match message is thespian.actors.WakeupMessage:
                self.next()


class MidiOut(thespian.actors.Actor):
    
    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_output('Launchpad MK2 MIDI 1')

    def send(self, kind, data):
        self.port.send(mido.Message(kind).from_bytes(data))
        
    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('send', kind, data):
                self.send(kind, data)


def note_to_coordinate(note):
    return Coordinate(row=note // 10 - 1, column=note % 10 - 1)


def velocity_to_event_type(velocity):
    if velocity:
        event_type = 'lp-button-down'
    else:
        event_type = 'lp-button-up'
    return event_type


class ButtonPressInterpreter(thespian.actors.Actor):
    initialized = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match ('midi-input-event', event):
                event_type = velocity_to_event_type(event.velocity)
                coordinate = note_to_coordinate(event.note)
                self.subscriptions.send_message((event_type, coordinate))
            

data Coordinate(row, column)
data Color(red, green, blue)

RED = Color(63, 0, 0)
GREEN = Color(0, 63, 0)
BLUE = Color(0, 0, 63)
YELLOW = Color(63, 40, 0)
BLACK = Color(0, 0, 0)
WHITE = Color(63, 63, 63)
DARK_WHITE = Color(15, 15, 15)
ORANGE = Color(63, 20, 0)


def coordinate_to_index(Coordinate(row, column)):
    # The top row (round buttons) are indexed differently.
    if row == 8:
        index = 104 + column
    else:
        index = (row + 1) * 10 + (column + 1)

    assert index <= 89 or index >= 104
    return index


def build_lights_commands(lights):
    commands = [240, 0, 32, 41, 2, 16, 11]
    for coordinate, color in lights:
        index = coordinate_to_index(coordinate)
        commands.extend([index, *color])
    commands.append(247)
    return commands


CLEAR_LIGHTS = [240, 0, 32, 41, 2, 24, 14, 0, 247]


class LaunchpadLights(thespian.actors.Actor):
    initialized = False
    midi_out = None

    def init(self):
        self.wakeupAfter(datetime.timedelta())

        # We need to clear any lights currently enabled on the launchpad.
        # If we have not yet been told about the MIDI output agent we are
        # to send messages to, then we can not initialize yet.  
        if self.midi_out is None:
            return

        self.initialized = True
        self.pixels = {}
        self.last_pixels = {}
        self.send(self.midi_out, ('send', 'sysex', CLEAR_LIGHTS))

    def set_color(self, coordinate, color):
        self.pixels[coordinate] = color

    def render(self):
        changes = set(self.pixels.items()) - set(self.last_pixels.items())
        self.send(self.midi_out, ('send', 'sysex', build_lights_commands(changes)))
        self.last_pixels = dict(self.pixels)
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-midi-out', midi_out):
                self.midi_out = midi_out
            match 'clear':
                self.init()
            match ('set', coordinate, color):
                self.set_color(coordinate, color)
            match message is thespian.actors.WakeupMessage:
                self.render()


class ButtonIndicator(thespian.actors.Actor):

    pressed_color = BLUE
    on_color = DARK_WHITE
    off_color = BLACK

    def button_pressed(self, coordinate):
        self.send(self.lights, ('set', coordinate, self.pressed_color))

    def button_on(self, coordinate):
        self.send(self.lights, ('set', coordinate, self.on_color))

    def button_off(self, coordinate):
        self.send(self.lights, ('set', coordinate, self.off_color))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('set-pressed-color', color):
                self.pressed_color = color
            match ('set-on-color', color):
                self.on_color = color
            match ('set-off-color', color):
                self.off_color = color
            match ('button-pressed', coordinate):
                self.button_pressed(coordinate)
            match ('button-on', coordinate):
                self.button_on(coordinate)
            match ('button-off', coordinate):
                self.button_off(coordinate)


class ToggleButton(thespian.actors.Actor):

    initialized = False
    on = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def button_pressed(self):
        self.subscriptions.send_message(('toggle-pressed', self.coordinate))

    def toggle(self):
        self.on ^= True
        state = ('toggle-off', 'toggle-on')[self.on]
        self.subscriptions.send_message((state, self.coordinate))
        # The other subscription messages are about visual indication of
        # state, this message is for anyone tracking the value of the button.
        self.subscriptions.send_message(('value-changed', self.on))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match ('set-coordinate', coordinate):
                self.coordinate = coordinate
            match ('lp-button-down', coordinate):
                if coordinate == self.coordinate:
                    self.button_pressed()
            match ('lp-button-up', coordinate):
                if coordinate == self.coordinate:
                    self.toggle()


class ToggleButtonIndicator(thespian.actors.Actor):

    def toggle_pressed(self, coordinate):
        self.send(self.indicator, ('button-pressed', coordinate))

    def toggle_on(self, coordinate):
        self.send(self.indicator, ('button-on', coordinate))

    def toggle_off(self, coordinate):
        self.send(self.indicator, ('button-off', coordinate))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-indicator', indicator):
                self.indicator = indicator
            match ('toggle-pressed', coordinate):
                self.toggle_pressed(coordinate)
            match ('toggle-on', coordinate):
                self.toggle_on(coordinate)
            match ('toggle-off', coordinate):
                self.toggle_off(coordinate)


class ToggleButtonBlinker(thespian.actors.Actor):

    def button_down(self, coordinate):
        self.send(self.lighter, ('button-pressed', coordinate))

    def toggle_on(self, coordinate):
        self.send(self.lighter, ('button-off', coordinate))
        self.send(self.blinker, ('start-blinking', coordinate))

    def toggle_off(self, coordinate):
        self.send(self.blinker, ('stop-blinking', coordinate))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-indicator', lighter):
                self.lighter = lighter
            match ('set-blinker', blinker):
                self.blinker = blinker
            match ('toggle-pressed', coordinate):
                self.button_down(coordinate)
            match ('toggle-on', coordinate):
                self.toggle_on(coordinate)
            match ('toggle-off', coordinate):
                self.toggle_off(coordinate)


class MessagePrinter(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        print(message)


class Nopper(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        pass


def run():
    system = thespian.actors.ActorSystem()
    nopper = system.createActor(Nopper)
    midi_in = system.createActor(MidiIn)
    midi_out = system.createActor(MidiOut)

    lights = system.createActor(LaunchpadLights)
    system.tell(lights, ('set-midi-out', midi_out))

    button_press_interpreter = system.createActor(ButtonPressInterpreter)
    system.tell(midi_in, ('subscribe', button_press_interpreter))

    button_indicator = system.createActor(ButtonIndicator)
    system.tell(button_indicator, ('set-lights', lights))

    toggle_button_indicator = system.createActor(ToggleButtonIndicator)
    system.tell(toggle_button_indicator, ('set-indicator', button_indicator))

    toggle_button_blinker = system.createActor(ToggleButtonBlinker)
    system.tell(toggle_button_blinker, ('set-blinker', button_blinker))
    system.tell(toggle_button_blinker, ('set-indicator', button_indicator))

    for column in range(8):
        button = system.createActor(ToggleButton)
        system.tell(button, ('set-coordinate', Coordinate(1, column)))
        system.tell(button, ('subscribe', toggle_button_blinker))
        system.tell(button_press_interpreter, ('subscribe', button))

    for column in range(8):
        button = system.createActor(ToggleButton)
        system.tell(button, ('set-coordinate', Coordinate(0, column)))
        system.tell(button, ('subscribe', toggle_button_indicator))
        system.tell(button_press_interpreter, ('subscribe', button))


    printer = system.createActor(MessagePrinter)
    #system.tell(button_press_interpreter, ('subscribe', printer))
    #system.tell(toggle_button_1, ('subscribe', printer))

    while True:
        # How do I keep messages flowing without doing this?
        system.tell(nopper, 'nop')
        time.sleep(.01)

    system.shutdown()


if __name__ == '__main__':
    run()
