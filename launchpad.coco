import datetime
import mido
import thespian.actors
import time

class UnrecognizedMessage(ValueError):
    pass


class SubscriptionManager(object):

    def __init__(self, send_func):
        self.subscribers = []
        self.send_func = send_func

    def new(self, subscriber):
        self.subscribers.append(subscriber)

    def send_message(self, message):
        for subscriber in self.subscribers:
            self.send_func(subscriber, message)


class MidiIn(thespian.actors.Actor):
    
    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_input('Launchpad MK2 MIDI 1')
        self.subscriptions = SubscriptionManager(send_func=self.send)
        self.wakeupAfter(datetime.timedelta())

    def next(self):
        midi_message = self.port.poll()
        if midi_message is not None:
            self.subscriptions.send_message(('midi-input-event', midi_message))
        self.wakeupAfter(datetime.timedelta(milliseconds=10))
        
    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match message is thespian.actors.WakeupMessage:
                self.next()
        else:
            raise UnrecognizedMessage(message)


class MidiOut(thespian.actors.Actor):
    
    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_output('Launchpad MK2 MIDI 1')

    def send(self, kind, data):
        self.port.send(mido.Message(kind).from_bytes(data))
        
    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('send', kind, data):
                self.send(kind, data)
        else:
            raise UnrecognizedMessage(message)


def note_to_coordinate(note):
    return Coordinate(row=note // 10 - 1, column=note % 10 - 1)


def velocity_to_event_type(velocity):
    if velocity:
        event_type = 'lp-button-down'
    else:
        event_type = 'lp-button-up'
    return event_type


class ButtonPressInterpreter(thespian.actors.Actor):
    initialized = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match ('midi-input-event', event):
                event_type = velocity_to_event_type(event.velocity)
                coordinate = note_to_coordinate(event.note)
                self.subscriptions.send_message((event_type, coordinate))
        else:
            raise UnrecognizedMessage(message)
            

data Coordinate(row, column)
data Color(red, green, blue)

RED = Color(63, 0, 0)
GREEN = Color(0, 63, 0)
BLUE = Color(0, 0, 63)
YELLOW = Color(63, 40, 0)
BLACK = Color(0, 0, 0)
WHITE = Color(63, 63, 63)
DARK_WHITE = Color(15, 15, 15)
ORANGE = Color(63, 20, 0)


def coordinate_to_index(Coordinate(row, column)):
    # The top row (round buttons) are indexed differently.
    if row == 8:
        index = 104 + column
    else:
        index = (row + 1) * 10 + (column + 1)

    assert index <= 89 or index >= 104
    return index


def build_lights_commands(lights):
    commands = [240, 0, 32, 41, 2, 16, 11]
    for coordinate, color in lights:
        index = coordinate_to_index(coordinate)
        commands.extend([index, *color])
    commands.append(247)
    return commands


CLEAR_LIGHTS = [240, 0, 32, 41, 2, 24, 14, 0, 247]


class LaunchpadLights(thespian.actors.Actor):
    initialized = False
    midi_out = None

    def init(self):
        self.wakeupAfter(datetime.timedelta())

        # We need to clear any lights currently enabled on the launchpad.
        # If we have not yet been told about the MIDI output agent we are
        # to send messages to, then we can not initialize yet.  
        if self.midi_out is None:
            return

        self.initialized = True
        self.pixels = {}
        self.last_pixels = {}
        self.send(self.midi_out, ('send', 'sysex', CLEAR_LIGHTS))

    def set_color(self, coordinate, color):
        self.pixels[coordinate] = color

    def render(self):
        changes = set(self.pixels.items()) - set(self.last_pixels.items())
        self.send(self.midi_out, ('send', 'sysex', build_lights_commands(changes)))
        self.last_pixels = dict(self.pixels)
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-midi-out', midi_out):
                self.midi_out = midi_out
            match 'clear':
                self.init()
            match ('set', coordinate, color):
                self.set_color(coordinate, color)
            match message is thespian.actors.WakeupMessage:
                self.render()
        else:
            raise UnrecognizedMessage(message)


class ButtonLighter(thespian.actors.Actor):

    def light_on(self, coordinate):
        self.send(self.lights, ('set', coordinate, BLUE))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('lp-button-down', coordinate):
                self.light_on(coordinate)
            match ('lp-button-up', coordinate):
                pass
        else:
            raise UnrecognizedMessage(message)


class ButtonBlinker(thespian.actors.Actor):

    initialized = False
    blinking = f{}
    on_color = DARK_WHITE
    off_color = BLACK
    on = True

    def init(self):
        self.initialized = True
        self.wakeupAfter(datetime.timedelta())

    def start_blinking(self, coordinate):
        self.blinking |= f{coordinate}
        self.send(self.lights, ('set', coordinate, self.on_color))

    def stop_blinking(self, coordinate):
        self.blinking -= f{coordinate}
        self.send(self.lights, ('set', coordinate, self.off_color))

    def blink(self):
        color = [BLACK, DARK_WHITE][self.on]
        for coordinate in self.blinking:
            self.send(self.lights, ('set', coordinate, color))
        self.on ^= True
        self.wakeupAfter(datetime.timedelta(milliseconds=500))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('set-on-color', color):
                self.on_color = color
            match ('set-off-color', color):
                self.off_color = color
            match ('start-blinking', coordinate):
                self.start_blinking(coordinate)
            match ('stop-blinking', coordinate):
                self.stop_blinking(coordinate)
            match message is thespian.actors.WakeupMessage:
                self.blink()
        else:
            raise UnrecognizedMessage(message)


class ButtonFader(thespian.actors.Actor):

    initialized = False

    def init(self):
        self.initialized = True
        self.levels = {}
        self.wakeupAfter(datetime.timedelta())

    def start_fade(self, coordinate):
        self.levels[coordinate] = 63

    def fade(self):
        self.levels = {
            coordinate:level-1
            for (coordinate, level) in self.levels.items()
            if level > 0}
        for coordinate, level in self.levels.items():
            self.send(self.lights, ('set', coordinate, Color(level, level, level)))
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('lp-button-down', coordinate):
                pass
            match ('lp-button-up', coordinate):
                self.start_fade(coordinate)
            match message is thespian.actors.WakeupMessage:
                self.fade()
        else:
            raise UnrecognizedMessage(message)


class ToggleButton(thespian.actors.Actor):

    initialized = False
    on = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def toggle(self):
        self.on ^= True
        if self.on:
            self.send(self.blinker, ('start-blinking', self.coordinate))
            self.subscriptions.send_message(('button-on', self.coordinate))
        else:
            self.send(self.blinker, ('stop-blinking', self.coordinate))
            self.subscriptions.send_message(('button-off', self.coordinate))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match ('set-coordinate', coordinate):
                self.coordinate = coordinate
            match ('set-blinker', blinker):
                self.blinker= blinker
            match ('lp-button-down', coordinate):
                pass
            match ('lp-button-up', coordinate):
                if coordinate == self.coordinate:
                    self.toggle()
        else:
            raise UnrecognizedMessage(message)


class MessagePrinter(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        print(message)


class Nopper(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        pass


def run():
    system = thespian.actors.ActorSystem()
    nopper = system.createActor(Nopper)
    midi_in = system.createActor(MidiIn)
    midi_out = system.createActor(MidiOut)

    lights = system.createActor(LaunchpadLights)
    system.tell(lights, ('set-midi-out', midi_out))

    button_press_interpreter = system.createActor(ButtonPressInterpreter)
    system.tell(midi_in, ('subscribe', button_press_interpreter))

    button_lighter = system.createActor(ButtonLighter)
    system.tell(button_lighter, ('set-lights', lights))
    system.tell(button_press_interpreter, ('subscribe', button_lighter))

    #button_fader = system.createActor(ButtonFader)
    #system.tell(button_fader, ('set-lights', lights))
    #system.tell(button_press_interpreter, ('subscribe', button_fader))

    button_blinker = system.createActor(ButtonBlinker)
    system.tell(button_blinker, ('set-lights', lights))

    toggle_button = system.createActor(ToggleButton)
    system.tell(toggle_button, ('set-blinker', button_blinker))
    system.tell(toggle_button, ('set-coordinate', Coordinate(1, 2)))
    system.tell(button_press_interpreter, ('subscribe', toggle_button))

    printer = system.createActor(MessagePrinter)
    #system.tell(button_press_interpreter, ('subscribe', printer))
    system.tell(toggle_button, ('subscribe', printer))

    while True:
        # How do I keep messages flowing without doing this?
        system.tell(nopper, 'nop')
        time.sleep(.01)

    system.shutdown()


if __name__ == '__main__':
    run()
