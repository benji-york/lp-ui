import datetime
import mido
import thespian.actors
import time

class UnrecognizedMessage(ValueError):
    pass


class SubscriptionManager(object):

    def __init__(self, send_func):
        self.subscribers = []
        self.send_func = send_func

    def new(self, subscriber):
        self.subscribers.append(subscriber)

    def send_message(self, message):
        for subscriber in self.subscribers:
            self.send_func(subscriber, message)


class MidiIn(thespian.actors.Actor):
    
    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_input('Launchpad MK2 MIDI 1')
        self.subscriptions = SubscriptionManager(send_func=self.send)
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def next(self):
        midi_message = self.port.poll()
        if midi_message is not None:
            self.subscriptions.send_message(('midi-input-event', midi_message))
        self.wakeupAfter(datetime.timedelta(milliseconds=10))
        
    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match message is thespian.actors.WakeupMessage:
                self.next()
        else:
            raise UnrecognizedMessage(message)


class MidiOut(thespian.actors.Actor):
    
    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_output('Launchpad MK2 MIDI 1')

    def send(self, kind, data):
        self.port.send(mido.Message(kind).from_bytes(data))
        
    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('send', kind, data):
                self.send(kind, data)
        else:
            raise UnrecognizedMessage(message)


class ButtonPressInterpreter(thespian.actors.Actor):
    initialized = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match ('midi-input-event', event):
                coordinate = Coordinate(row=event.note // 10 - 1, column=event.note % 10 - 1)
                if event.velocity:
                    event_type = 'lp-button-down'
                else:
                    event_type = 'lp-button-up'

                self.subscriptions.send_message((event_type, coordinate))
        else:
            raise UnrecognizedMessage(message)
            

data Coordinate(row, column)
data Color(red, green, blue)

RED = Color(63, 0, 0)
GREEN = Color(0, 63, 0)
BLUE = Color(0, 0, 63)
YELLOW = Color(63, 40, 0)
BLACK = Color(0, 0, 0)
WHITE = Color(63, 63, 63)
DARK_WHITE = Color(15, 15, 15)
ORANGE = Color(63, 20, 0)


def coordinate_to_index(Coordinate(row, column)):
    # The top row (round buttons) are indexed differently.
    if row == 8:
        index = 104 + column
    else:
        index = (row + 1) * 10 + (column + 1)

    assert index <= 89 or index >= 104
    return index


def build_lights_commands(lights):
    commands = [240, 0, 32, 41, 2, 16, 11]
    for coordinate, color in lights:
        index = coordinate_to_index(coordinate)
        commands.extend([index, *color])
    commands.append(247)
    return commands


CLEAR_LIGHTS = [240, 0, 32, 41, 2, 24, 14, 0, 247]


class LaunchpadLights(thespian.actors.Actor):
    initialized = False

    def set_color(self, coordinate, color):
        self.send(
            self.midi_out, ('send', 'sysex', build_lights_commands([(coordinate, color)])))

    def clear(self):
        self.send(self.midi_out, ('send', 'sysex', CLEAR_LIGHTS))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-midi-out', midi_out):
                self.midi_out = midi_out
            match 'clear':
                self.clear()
            match ('set', coordinate, color):
                self.set_color(coordinate, color)
        else:
            raise UnrecognizedMessage(message)


class ButtonLighter(thespian.actors.Actor):

    def light_on(self, coordinate):
        self.send(self.lights, ('set', coordinate, DARK_WHITE))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('lp-button-down', coordinate):
                self.light_on(coordinate)
            match ('lp-button-up', coordinate):
                pass
        else:
            raise UnrecognizedMessage(message)


class ButtonBlinker(thespian.actors.Actor):

    initialized = False
    blinking = f{}
    on = True

    def init(self):
        self.initialized = True
        self.wakeupAfter(datetime.timedelta(milliseconds=500))

    def toggle_blinking(self, coordinate):
        self.blinking ^= f{coordinate}
        self.send(self.lights, ('set', coordinate, BLACK))

    def blink(self):
        color = [BLACK, DARK_WHITE][self.on]
        for coordinate in self.blinking:
            self.send(self.lights, ('set', coordinate, color))
        self.on ^= True
        self.wakeupAfter(datetime.timedelta(milliseconds=500))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('lp-button-down', coordinate):
                self.toggle_blinking(coordinate)
            match ('lp-button-up', coordinate):
                pass
            match message is thespian.actors.WakeupMessage:
                self.blink()
        else:
            raise UnrecognizedMessage(message)



class ButtonFader(thespian.actors.Actor):

    initialized = False
    levels = f{}

    def init(self):
        self.initialized = True
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def start_fade(self, coordinate):
        self.levels |= f{(coordinate, 63)}

    def fade(self):
        for coordinate, level in self.levels:
            self.send(self.lights, ('set', coordinate, Color(level, level, level)))
        self.levels = f{(coordinate, level-1) for (coordinate, level) in self.levels}
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('lp-button-down', coordinate):
                self.start_fade(coordinate)
            match ('lp-button-up', coordinate):
                pass
            match message is thespian.actors.WakeupMessage:
                self.fade()
        else:
            raise UnrecognizedMessage(message)



class MessagePrinter(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        print(message)


class Nopper(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        pass


def run():
    system = thespian.actors.ActorSystem()
    nopper = system.createActor(Nopper)
    midi_in = system.createActor(MidiIn)
    midi_out = system.createActor(MidiOut)
    printer = system.createActor(MessagePrinter)
    button_press_interpreter = system.createActor(ButtonPressInterpreter)
    lights = system.createActor(LaunchpadLights)
    button_lighter = system.createActor(ButtonFader)

    system.tell(midi_in, ('subscribe', button_press_interpreter))
    system.tell(lights, ('set-midi-out', midi_out))
    system.tell(lights, 'clear')
    system.tell(button_lighter, ('set-lights', lights))
    system.tell(button_press_interpreter, ('subscribe', button_lighter))
    system.tell(button_press_interpreter, ('subscribe', printer))

    while True:
        # How do I keep messages flowing without doing this?
        system.tell(nopper, 'nop')
        time.sleep(.01)

    system.shutdown()


if __name__ == '__main__':
    run()
