import datetime
import mido
import thespian.actors
import time


class SubscriptionManager(object):

    def __init__(self, send_func):
        self.subscribers = []
        self.send_func = send_func

    def new(self, subscriber):
        self.subscribers.append(subscriber)

    def send_message(self, message):
        for subscriber in self.subscribers:
            self.send_func(subscriber, message)


class MidiIn(thespian.actors.Actor):

    initialized = False

    def init(self):
        self.initialized = True
        self.port = mido.open_input('Launchpad MK2 MIDI 1')
        self.subscriptions = SubscriptionManager(send_func=self.send)
        self.wakeupAfter(datetime.timedelta())

    def next(self):
        midi_message = self.port.poll()
        if midi_message is not None:
            self.subscriptions.send_message(('midi-input-event', midi_message))
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match message is thespian.actors.WakeupMessage:
                self.next()


class MidiOut(thespian.actors.Actor):

    initialized = False
    ready = False

    def init(self):
        self.initialized = True
        self.queued_messages = []
        self.port = mido.open_output('Launchpad MK2 MIDI 1')
        # The Launchpad needs a little time to be ready to accept commands.
        self.wakeupAfter(datetime.timedelta(milliseconds=500))

    def send_midi_event(self, kind, data):
        self.port.send(mido.Message(kind).from_bytes(data))

    def handle_message(self, message):
        case message:
            match ('send', kind, data):
                self.send_midi_event(kind, data)

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        # The only thing that send WakeupMessages is self.init() to give the
        # Launchpad time to get ready.  If we receive one, that means the time
        # has elapsed and we assume it is ready to go.
        if message `isinstance` thespian.actors.WakeupMessage:
            self.ready = True

        # Since we have to queue some messages, we'll just queue them all.
        self.queued_messages.append(message)

        if self.ready:
            for message in self.queued_messages:
                self.handle_message(message)
            del self.queued_messages[:]


data Coordinate(row, column):
    def __add__(self, other):
        return Coordinate(self.row + other.row, self.column + other.column)

data Vector(row, column)

def note_to_coordinate(note):
    return Coordinate(row=note // 10 - 1, column=note % 10 - 1)


def velocity_to_event_type(velocity):
    if velocity:
        event_type = 'lp-button-down'
    else:
        event_type = 'lp-button-up'
    return event_type


class ButtonPressInterpreter(thespian.actors.Actor):
    initialized = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
            match ('midi-input-event', event):
                event_type = velocity_to_event_type(event.velocity)
                coordinate = note_to_coordinate(event.note)
                self.subscriptions.send_message((event_type, coordinate))


data Color(red, green, blue)

RED = Color(63, 0, 0)
GREEN = Color(0, 63, 0)
BLUE = Color(0, 0, 63)
YELLOW = Color(63, 40, 0)
BLACK = Color(0, 0, 0)
DARK_WHITE = Color(2, 2, 2)
MEDIUM_WHITE = Color(15, 15, 15)
BRIGHT_WHITE = Color(63, 63, 63)
ORANGE = Color(63, 20, 0)


def coordinate_to_index(Coordinate(row, column)):
    # The top row (round buttons) are indexed differently.
    if row == 8:
        index = 104 + column
    else:
        index = (row + 1) * 10 + (column + 1)

    assert index <= 89 or index >= 104
    return index


def build_lights_commands(lights):
    commands = [240, 0, 32, 41, 2, 16, 11]
    for coordinate, color in lights:
        index = coordinate_to_index(coordinate)
        commands.extend([index, *color])
    commands.append(247)
    return commands


CLEAR_LIGHTS = [240, 0, 32, 41, 2, 24, 14, 0, 247]


class LaunchpadLights(thespian.actors.Actor):
    initialized = False

    def init(self):
        self.initialized = True
        self.pixels = {}
        self.last_pixels = {}
        self.send(self.midi_out, ('send', 'sysex', CLEAR_LIGHTS))
        # Prime the pump.
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def set_color(self, coordinate, color):
        self.pixels[coordinate] = color

    def render(self):
        assert self.initialized, 'render called too early'
        changes = sorted(set(self.pixels.items()) - set(self.last_pixels.items()))
        if changes:
            self.send(self.midi_out, ('send', 'sysex', build_lights_commands(changes)))
            self.last_pixels = dict(self.pixels)
        self.wakeupAfter(datetime.timedelta(milliseconds=10))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-midi-out', midi_out):
                self.midi_out = midi_out
                assert not self.initialized
                self.init()
            match ('set', coordinate, color):
                self.set_color(coordinate, color)
            match message is thespian.actors.WakeupMessage:
                self.render()


class ButtonIndicator(thespian.actors.Actor):

    pressed_color = BLUE
    on_color = MEDIUM_WHITE
    off_color = BLACK

    def button_pressed(self, coordinate):
        self.send(self.lights, ('set', coordinate, self.pressed_color))

    def button_on(self, coordinate):
        self.send(self.lights, ('set', coordinate, self.on_color))

    def button_off(self, coordinate):
        self.send(self.lights, ('set', coordinate, self.off_color))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('set-pressed-color', color):
                self.pressed_color = color
            match ('set-on-color', color):
                self.on_color = color
            match ('set-off-color', color):
                self.off_color = color
            match ('button-pressed', coordinate):
                self.button_pressed(coordinate)
            match ('button-on', coordinate):
                self.button_on(coordinate)
            match ('button-off', coordinate):
                self.button_off(coordinate)


class ButtonBlinker(thespian.actors.Actor):

    initialized = False
    blinking = f{}
    on_color = MEDIUM_WHITE
    off_color = BLACK
    on = True

    def init(self):
        self.initialized = True
        self.wakeupAfter(datetime.timedelta())

    def start_blinking(self, coordinate):
        self.blinking |= f{coordinate}

    def stop_blinking(self, coordinate):
        self.blinking -= f{coordinate}
        self.send(self.lights, ('set', coordinate, self.off_color))

    def blink(self):
        color = [self.off_color, self.on_color][self.on]
        for coordinate in self.blinking:
            self.send(self.lights, ('set', coordinate, color))
        self.on ^= True
        self.wakeupAfter(datetime.timedelta(milliseconds=500))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-lights', lights):
                self.lights = lights
            match ('set-on-color', color):
                self.on_color = color
            match ('set-off-color', color):
                self.off_color = color
            match ('start-blinking', coordinate):
                self.start_blinking(coordinate)
            match ('stop-blinking', coordinate):
                self.stop_blinking(coordinate)
            match message is thespian.actors.WakeupMessage:
                self.blink()


class ToggleButton(thespian.actors.Actor):

    initialized = False
    on = False

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    def button_pressed(self):
        self.subscriptions.send_message(('toggle-pressed', self.coordinate))

    def toggle(self):
        self.on ^= True
        self.update_subscribers()

    def update_subscribers(self):
        state = ('toggle-off', 'toggle-on')[self.on]
        self.subscriptions.send_message((state, self.coordinate))
        # The other subscription messages are about visual indication of
        # state, this message is for anyone tracking the value of the button.
        self.subscriptions.send_message(('value', self.on))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
                self.update_subscribers()
            match ('set-coordinate', coordinate):
                self.coordinate = coordinate
            match ('lp-button-down', coordinate):
                if coordinate == self.coordinate:
                    self.button_pressed()
            match ('lp-button-up', coordinate):
                if coordinate == self.coordinate:
                    self.toggle()


class ToggleButtonIndicator(thespian.actors.Actor):

    def toggle_pressed(self, coordinate):
        self.send(self.indicator, ('button-pressed', coordinate))

    def toggle_on(self, coordinate):
        self.send(self.indicator, ('button-on', coordinate))

    def toggle_off(self, coordinate):
        self.send(self.indicator, ('button-off', coordinate))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-indicator', indicator):
                self.indicator = indicator
            match ('toggle-pressed', coordinate):
                self.toggle_pressed(coordinate)
            match ('toggle-on', coordinate):
                self.toggle_on(coordinate)
            match ('toggle-off', coordinate):
                self.toggle_off(coordinate)


class ToggleButtonBlinker(thespian.actors.Actor):

    def button_down(self, coordinate):
        self.send(self.lighter, ('button-pressed', coordinate))

    def toggle_on(self, coordinate):
        self.send(self.lighter, ('button-off', coordinate))
        self.send(self.blinker, ('start-blinking', coordinate))

    def toggle_off(self, coordinate):
        self.send(self.blinker, ('stop-blinking', coordinate))

    def receiveMessage(self, message, sender):
        case message:
            match ('set-indicator', lighter):
                self.lighter = lighter
            match ('set-blinker', blinker):
                self.blinker = blinker
            match ('toggle-pressed', coordinate):
                self.button_down(coordinate)
            match ('toggle-on', coordinate):
                self.toggle_on(coordinate)
            match ('toggle-off', coordinate):
                self.toggle_off(coordinate)


def versor(vector):
    if vector.row == 0:
        return Vector(0, 1)
    elif vector.column == 0:
        return Vector(1, 0)
    else:
        raise ValueError('only vectors parallel to an axis are suppored')


class Fader(thespian.actors.Actor):

    initialized = False
    max_coordinate = None

    def init(self):
        self.initialized = True
        self.subscriptions = SubscriptionManager(send_func=self.send)

    @property
    def coordinates(self):
        coordinate = self.origin
        end = self.origin + self.vector
        coordinates = []
        while True:
            coordinates.append(coordinate)
            if coordinate == end:
                break
            coordinate += versor(self.vector)
        return coordinates

    def get_on_coordinates(self):
        coordinates = []
        for coordinate in self.coordinates:
            coordinates.append(coordinate)
            if coordinate == self.max_coordinate:
                return coordinates
        raise RuntimeError('coordinates calculation failed')

    def button_down(self, coordinate):
        if coordinate not in self.coordinates:
            return

        self.subscriptions.send_message(('button-pressed', coordinate))

    def button_up(self, coordinate):
        if coordinate not in self.coordinates:
            return

        self.max_coordinate = coordinate
        self.update_subscribers()

    def update_subscribers(self):
        on_coordinates = self.get_on_coordinates()
        # Tell subscribers about all the currently-on buttons.
        for coordinate in on_coordinates:
            self.subscriptions.send_message(('button-on', coordinate))

        # Tell subscribers about all the currently-off buttons.
        off_coordinates = set(self.coordinates) - set(on_coordinates)
        for coordinate in off_coordinates:
            self.subscriptions.send_message(('button-off', coordinate))

        level = len(on_coordinates) - 1
        self.subscriptions.send_message(('value', level))

    def receiveMessage(self, message, sender):
        if not self.initialized:
            self.init()

        case message:
            match ('set-origin', coordinate):
                self.origin = coordinate
                if self.max_coordinate is None:
                    self.max_coordinate = coordinate
            match ('set-vector', vector):
                assert 0 in vector, "At least one of the vector's dimensions must be zero."
                self.vector = vector
            match ('subscribe', subscriber):
                self.subscriptions.new(subscriber)
                # New subscribers shouldn't have to wait for something to
                # change to get the current state of affairs.
                self.update_subscribers()
            match ('lp-button-down', coordinate):
                self.button_down(coordinate)
            match ('lp-button-up', coordinate):
                self.button_up(coordinate)


class MessagePrinter(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        print(message)


class Nopper(thespian.actors.Actor):

    def receiveMessage(self, message, sender):
        pass


def create_and_tell(system, actor_class, *kv_pairs):
    actor = system.createActor(actor_class)
    for key, value in kv_pairs:
        system.tell(actor, (key, value))
    return actor


def run():
    #system = thespian.actors.ActorSystem()
    #system = thespian.actors.ActorSystem('multiprocQueueBase')
    system = thespian.actors.ActorSystem('multiprocUDPBase')
    create = (actor_class, *kv_pairs) -> create_and_tell(system, actor_class, *kv_pairs)
    subscribe = (to, subscriber) -> system.tell(to, ('subscribe', subscriber))

    nopper = system.createActor(Nopper)
    midi_in = system.createActor(MidiIn)
    midi_out = system.createActor(MidiOut)

    lights = create(
        LaunchpadLights,
        ('set-midi-out', midi_out))

    button_press_interpreter = create(ButtonPressInterpreter)
    subscribe(midi_in, button_press_interpreter)

    fader_button_indicator = create(
        ButtonIndicator,
        ('set-lights', lights))

    mute_button_indicator = create(
        ButtonIndicator,
        ('set-lights', lights),
        ('set-on-color', RED))

    solo_button_indicator = create(
        ButtonIndicator,
        ('set-lights', lights))

    toggle_button_indicator = create(
        ToggleButtonIndicator,
        ('set-indicator', mute_button_indicator))

    solo_button_blinker = create(
        ButtonBlinker,
        ('set-lights', lights),
        ('set-on-color', GREEN))

    toggle_button_blinker = create(
        ToggleButtonBlinker,
        ('set-blinker', solo_button_blinker),
        ('set-indicator', solo_button_indicator))

    printer = system.createActor(MessagePrinter)

    actors = []
    for column in range(8):
        button = create(ToggleButton, ('set-coordinate', Coordinate(1, column)))
        button `subscribe` toggle_button_blinker
        button_press_interpreter `subscribe` button
        actors.append(button)

    for column in range(8):
        button = create(
            ToggleButton,
            ('set-coordinate', Coordinate(0, column)),
            ('subscribe', toggle_button_indicator))
        button_press_interpreter `subscribe` button
        actors.append(button)

    for column in range(8):
        fader = create(
            Fader,
            ('set-origin', Coordinate(2, column)),
            ('set-vector', Vector(5, 0)),
            ('subscribe', fader_button_indicator))
        button_press_interpreter `subscribe` fader
        actors.append(fader)

    try:
        while True:
            system.listen(datetime.timedelta(seconds=1))
    finally:
        system.shutdown()


if __name__ == '__main__':
    run()
